'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactLeaflet = require('react-leaflet');

var _leaflet = require('leaflet');

var _leaflet2 = _interopRequireDefault(_leaflet);

require('leaflet.vectorgrid');

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _debug2.default)('react-leaflet-vectorgrid');

function patchVectorGridLayer(obj) {
	// Fix error for point data.
	// eg. mouseover does not work without this.
	debug('patch before', { obj: obj });
	obj._createLayer_orig = obj._createLayer;
	obj._createLayer = function (feat, pxPerExtent, layerStyle) {
		var layer = this._createLayer_orig(feat, pxPerExtent, layerStyle);
		if (feat.type === 1) {
			layer.getLatLng = null;
		}
		return layer;
	};

	// do this for chaining
	debug('patch after', { obj: obj });
	return obj;
}

function isObject(x) {
	return x === Object(x);
}

function isFunction(x) {
	return typeof x === 'function';
}

function isString(x) {
	return typeof x === 'string' || x instanceof String;
}

function isEmpty(x) {
	return x && x.length === 0;
}

function cloneDeep(x) {
	return JSON.parse(JSON.stringify(obj));
}

function extend(a, b) {
	return Object.assign(a, b);
}

function clone(x) {
	return Object.assign({}, x);
}

function has(obj, path) {
	// guard.
	debug('has', { obj: obj, path: path });
	if (!isString(path)) return false;

	var keys = path.split('.');

	for (var i = 0; i < keys.length; i++) {
		if (!obj || !obj.hasOwnProperty(keys[i])) {
			return false;
		}
		obj = obj[keys[i]];
	}
	return true;
}

var VectorGrid = function (_MapLayer) {
	_inherits(VectorGrid, _MapLayer);

	function VectorGrid() {
		_classCallCheck(this, VectorGrid);

		return _possibleConstructorReturn(this, (VectorGrid.__proto__ || Object.getPrototypeOf(VectorGrid)).apply(this, arguments));
	}

	_createClass(VectorGrid, [{
		key: 'createLeafletElement',
		value: function createLeafletElement(props) {
			var _this2 = this;

			var _ref = props.leaflet || this.context,
			    map = _ref.map,
			    pane = _ref.pane,
			    layerContainer = _ref.layerContainer;

			var data = props.data,
			    zIndex = props.zIndex,
			    _props$type = props.type,
			    type = _props$type === undefined ? 'slicer' : _props$type,
			    style = props.style,
			    hoverStyle = props.hoverStyle,
			    activeStyle = props.activeStyle,
			    onClick = props.onClick,
			    onMouseover = props.onMouseover,
			    onMouseout = props.onMouseout,
			    onDblclick = props.onDblclick,
			    _props$interactive = props.interactive,
			    interactive = _props$interactive === undefined ? true : _props$interactive,
			    vectorTileLayerStyles = props.vectorTileLayerStyles,
			    url = props.url,
			    maxNativeZoom = props.maxNativeZoom,
			    maxZoom = props.maxZoom,
			    minZoom = props.minZoom,
			    subdomains = props.subdomains,
			    key = props.key,
			    token = props.token,
			    rest = _objectWithoutProperties(props, ['data', 'zIndex', 'type', 'style', 'hoverStyle', 'activeStyle', 'onClick', 'onMouseover', 'onMouseout', 'onDblclick', 'interactive', 'vectorTileLayerStyles', 'url', 'maxNativeZoom', 'maxZoom', 'minZoom', 'subdomains', 'key', 'token']);

			// get feature base styling


			var baseStyle = function baseStyle(properties, zoom) {
				if (isFunction(style)) {
					return style(properties);
				} else if (isObject(style)) {
					return style;
				}
				return {
					weight: 0.5,
					opacity: 1,
					color: '#ccc',
					fillColor: '#390870',
					fillOpacity: 0.6,
					fill: true,
					stroke: true
				};
			};
			this.highlight = null;
			this.active = null;

			var vectorGrid = void 0;

			if (type === 'protobuf') {
				vectorGrid = _leaflet2.default.vectorGrid.protobuf(url, _extends({
					vectorTileLayerStyles: vectorTileLayerStyles,
					interactive: interactive,
					url: url,
					maxNativeZoom: maxNativeZoom,
					subdomains: subdomains,
					key: key,
					token: token,
					zIndex: zIndex || Number(layerContainer._panes[pane] && layerContainer._panes[pane].style.zIndex),
					getFeatureId: function getFeatureId(feature) {
						return _this2._getFeatureId(feature);
					},
					rendererFactory: _leaflet2.default.svg.tile,
					maxZoom: maxZoom || map.getMaxZoom(),
					minZoom: minZoom || map.getMinZoom()
				}, rest));
			} else {
				vectorGrid = _leaflet2.default.vectorGrid.slicer(data, _extends({
					interactive: interactive,
					zIndex: zIndex || Number(layerContainer._panes[pane] && layerContainer._panes[pane].style.zIndex),
					getFeatureId: function getFeatureId(feature) {
						return _this2._getFeatureId(feature);
					},
					rendererFactory: _leaflet2.default.svg.tile,
					maxZoom: maxZoom || map.getMaxZoom(),
					minZoom: minZoom || map.getMinZoom(),
					vectorTileLayerStyles: vectorTileLayerStyles || {
						sliced: function sliced(properties, zoom) {
							var bs = baseStyle(properties, zoom);
							bs.fill = true;
							bs.stroke = true;
							return bs;
						}
					}
				}, rest));
			}

			return patchVectorGridLayer(vectorGrid).on('mouseover', function (e) {
				var properties = e.layer.properties;

				_this2._propagateEvent(onMouseover, e);

				// on mouseover styling
				var st = void 0;
				var featureId = _this2._getFeatureId(e.layer);
				if (isFunction(hoverStyle)) {
					st = hoverStyle(properties);
				} else if (isObject(hoverStyle)) {
					st = clone(hoverStyle);
				}
				if (!isEmpty(st) && featureId) {
					_this2.clearHighlight();
					_this2.highlight = featureId;
					var base = clone(baseStyle(properties));
					var hover = extend(base, st);
					_this2.setFeatureStyle(featureId, hover);
				}
			}).on('mouseout', function (e) {
				_this2._propagateEvent(onMouseout, e);
				_this2.clearHighlight();
			}).on('click', function (e) {
				var properties = e.layer.properties;

				var featureId = _this2._getFeatureId(e.layer);

				_this2._propagateEvent(onClick, e);

				// set active style
				var st = void 0;
				if (isFunction(activeStyle)) {
					st = activeStyle(properties);
				} else if (isObject(activeStyle)) {
					st = clone(activeStyle);
				}
				if (!isEmpty(st) && featureId) {
					_this2.clearActive();
					_this2.active = featureId;
					var base = clone(baseStyle(properties));
					var active = extend(base, st);
					_this2.setFeatureStyle(featureId, active);
				}
			}).on('dblclick', function (e) {
				_this2._propagateEvent(onDblclick, e);
				_this2.clearActive();
			});
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _ref2 = this.props.leaflet || this.context,
			    layerContainer = _ref2.layerContainer;

			var _props = this.props,
			    _props$tooltipClassNa = _props.tooltipClassName,
			    tooltipClassName = _props$tooltipClassNa === undefined ? '' : _props$tooltipClassNa,
			    _props$tooltip = _props.tooltip,
			    tooltip = _props$tooltip === undefined ? null : _props$tooltip,
			    _props$popup = _props.popup,
			    popup = _props$popup === undefined ? null : _props$popup;

			this.leafletElement.addTo(layerContainer);
			// bind tooltip
			if (tooltip) {
				this.leafletElement.bindTooltip(function (layer) {
					if (isFunction(tooltip)) {
						return tooltip(layer);
					} else if (isString(tooltip) && has(layer.properties, tooltip)) {
						return String(layer.properties[tooltip]);
					} else if (isString(tooltip)) {
						return tooltip;
					}
					return '';
				}, {
					sticky: true,
					direction: 'auto',
					className: tooltipClassName
				});
			}
			// bind popup
			// don't need all that extra logic, just make popup match the vector grid options.
			// TODO add the ability to pass through popup options
			if (popup) {
				// create a popup and bind it?
				// const newPopup = L.popup().setContent(popup);
				// debug('type of popup', newPopup instanceof Popup);
				debug('popup', { popup: popup });
				this.leafletElement.bindPopup(popup);
			}
		}
	}, {
		key: '_getFeatureId',
		value: function _getFeatureId(feature) {
			var idField = this.props.idField;

			if (isFunction(idField)) {
				return idField(feature);
			} else if (isString(idField)) {
				return feature.properties[idField];
			}
		}
	}, {
		key: '_propagateEvent',
		value: function _propagateEvent(eventHandler, e) {
			if (!isFunction(eventHandler)) return;
			var featureId = this._getFeatureId(e.layer);
			var feature = this.getFeature(featureId);
			var event = cloneDeep(e);
			var mergedEvent = merge(event.target, {
				feature: feature
			});
			eventHandler(event);
		}
	}, {
		key: 'setFeatureStyle',
		value: function setFeatureStyle(id, style) {
			this.leafletElement.setFeatureStyle(id, style);
		}
	}, {
		key: 'resetFeatureStyle',
		value: function resetFeatureStyle(id) {
			this.leafletElement.resetFeatureStyle(id);
		}
	}, {
		key: 'clearHighlight',
		value: function clearHighlight() {
			if (this.highlight && this.highlight !== this.active) {
				this.resetFeatureStyle(this.highlight);
			}
			this.highlight = null;
		}
	}, {
		key: 'clearActive',
		value: function clearActive() {
			if (this.active) {
				this.resetFeatureStyle(this.active);
			}
			this.active = null;
		}
	}, {
		key: 'getFeature',
		value: function getFeature(featureId) {
			var _props2 = this.props,
			    data = _props2.data,
			    idField = _props2.idField;

			if (isEmpty(data)) return {};
			var feature = find(data.features, function (_ref3) {
				var properties = _ref3.properties;
				return properties[idField] === featureId;
			});
			return cloneDeep(feature);
		}
	}]);

	return VectorGrid;
}(_reactLeaflet.MapLayer);

exports.default = VectorGrid;